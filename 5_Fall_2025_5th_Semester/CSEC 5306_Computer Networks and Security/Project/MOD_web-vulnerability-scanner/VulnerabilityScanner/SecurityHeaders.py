import urllib.request
from urllib.error import URLError, HTTPError


class SecurityHeaders:
    headers_list = [
        "Content-Security-Policy",
        "access-control-allow-origin",
        "Referrer-Policy",
        "Clear-Site-Data"
    ]
    deprecated_headers = [
        "x-content-security-policy",
        "x-webkit-csp",
        "Public-Key-Pins",
        "X-XSS-Protection"
    ]

    def __init__(self, givenurl, quiet, nohttps):
        """
        Initialize the SecurityHeaders class.
        Args:
            givenurl: The URL to check for security headers.
            quiet: Boolean to suppress console output if True.
            nohttps: Boolean to skip HTTPS-specific headers if True.
        """
        self.url = givenurl
        self.quiet = quiet
        if not nohttps:
            SecurityHeaders.headers_list.append("Strict-Transport-Security")

    def check_security_headers(self, report):
        """
        Check the security headers of the given URL and log recommendations.
        Args:
            report: Report file object to log the results.
        """
        if not self.quiet:
            print("[*] Checking security headers")

        # Make request to the given URL
        try:
            res = urllib.request.urlopen(self.url)
        except (HTTPError, URLError) as e:
            if not self.quiet:
                print(f"[!] Error accessing URL {self.url}: {e}")
            report.write_to_report(f"[Error] Unable to access URL {self.url}: {e}\n")
            return

        report.write_to_report(f"\n[*****] Security headers returned by URL: {self.url} [*****]\n\n")

        # Check for deprecated headers
        for header in self.deprecated_headers:
            if res.getheader(header):
                report.write_to_report(f"[Deprecated] Header found: {header}. Please switch to a secure header.\n")

        # Check for proper security headers
        for header in self.headers_list:
            if not res.getheader(header):
                report.write_to_report(f"[Recommendation] Header {header} not found. Consider implementing it!\n")

        # Check for specific security headers with proper values
        self.__check_specific_headers(res, report)

    def __check_specific_headers(self, res, report):
        """
        Check specific security headers for proper configuration.
        Args:
            res: HTTP response object.
            report: Report file object to log the results.
        """
        # Check for X-Frame-Options
        x_frame_options = res.headers.get('X-Frame-Options', '').lower()
        if x_frame_options not in ['deny', 'sameorigin']:
            report.write_to_report("[Recommendation] Header X-Frame-Options not found or not properly configured. "
                                   "Please implement this security header!\n")

        # Check for X-Content-Type-Options
        x_content_type_options = res.headers.get('X-Content-Type-Options', '').lower()
        if x_content_type_options != 'nosniff':
            report.write_to_report("[Recommendation] Header X-Content-Type-Options not found or not properly configured. "
                                   "Please implement this security header!\n")

        # Check for X-Download-Options
        x_download_options = res.headers.get('X-Download-Options', '').lower()
        if x_download_options != 'noopen':
            report.write_to_report("[Recommendation] File download security is OFF. Header X-Download-Options "
                                   "not found or not properly configured. Please implement this security header!\n")

        # Check for Cache-Control
        cache_control = res.headers.get('Cache-Control', '').lower()
        if not (cache_control.startswith('private') or cache_control.startswith('no-cache')):
            report.write_to_report("[Recommendation] No content caching policy. Header Cache-Control not found "
                                   "or not properly configured. Please implement this security header!\n")

        # Check for X-Permitted-Cross-Domain-Policies
        x_permitted_cross_domain_policies = res.headers.get('X-Permitted-Cross-Domain-Policies', '').lower()
        if x_permitted_cross_domain_policies not in ['master-only', 'none']:
            report.write_to_report("[Recommendation] Header X-Permitted-Cross-Domain-Policies not found or not properly configured. "
                                   "Please implement this security header!\n")